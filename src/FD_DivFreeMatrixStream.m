%% FD_DivFreeMatrixStream
% This function creates a matrix $M$ that contains the necessary
% information to create a divergence-free polynomial interpolant of the
% form:
%
% $$u(x,y) = \frac{\partial \psi}{\partial y}, \quad v(x,y) =
% -\frac{\partial \psi}{\partial x},$$
%
% $$\psi(x,y) = \sum_{i=0}^N \sum_{j=0}^N c_{ij}x^iy^j,$$
%
% where $N$ is the degree of the polynomial approximation for the stream
% function.
%
% Using a polynomial of this form, the vector field generated by $(u,v)$
% will be divergence-free. However, numerical experiments showed (so far)
% that the polynomials do not interpolate the test function exactly. A
% least-square solution is find.
%
%  INPUT:
%  dSites : interpolation points
%  N      : degree of the bivariate polynomial
%
%  OUTPUT:
%  M      : matrix to be inverted to find the desired polynomial
%  u, v   : polynomials that depends on its coefficients.
%  u?, v? : depends on (x,y), useful to calculate the numerical derivatives
%           at a point.
%
% NOTE: the output derivatives might be removed in the future, when we
% decide on the final format of the interpolant.

%%
function [M, u, v, ux, uy, vx, vy] = FD_DivFreeMatrixStream(dSites, N)

%% Setting up the function
n = length(dSites(:,1));  % number of interpolation points

%% Defining the stream function and divergence-free interpolant
% Note that we are using the symbolic toolbox, which make the code slower.
% However, it allows some flexibility for testing. Later we can rewrite the
% code to be computationally efficient.
syms x y

S = kron(x.^(0:N),y.^(0:N));
% Removing redundant terms ------------------------------------------------
S(1) = [];                        % Taking out the constant coefficient
% -------------------------------------------------------------------------

Sx = diff(S, x); v = -Sx;
Sy = diff(S, y); u = +Sy;   % div(rot( (0,0,S) )) = 0
coeffs = sym('c', [length(u), 1]);

if nargout > 3
    ux = diff(u, x); ux = matlabFunction(ux*coeffs,'vars',{x y coeffs});
    uy = diff(u, y); uy = matlabFunction(uy*coeffs,'vars',{x y coeffs});
    vx = diff(v, x); vx = matlabFunction(vx*coeffs,'vars',{x y coeffs});
    vy = diff(v, y); vy = matlabFunction(vy*coeffs,'vars',{x y coeffs});
end
u = matlabFunction(u,'vars',[x y]);
v = matlabFunction(v,'vars',[x y]);

%% The interpolation matrix is constructed line by line
% At this point, $u$ and $v$ are symbolic row vectors with entries being
% monomials terms of the polynomials that "interpolates" $(f_u,f_v)$. The
% matrix M is constructed such that:
%
%
% $$
% M * \tt{coeffs} = \left[
% \begin{array}{c}
%   U \\
%   V
% \end{array} \right] * \tt{coeffs} = \left[
% \begin{array}{c}
%   f_u(\tt{dSites}) \\
%   f_v(\tt{dSites})
% \end{array}\right],
% $$
%
% where the matrices $U = [u(\tt{dSites})]$ and $V = [v(\tt{dSites})]$ and,
% |dSites| is the list of interpolation points.

% There are (N+1)^2 - 1 coeffs at most
U = zeros(n, length(S));
V = zeros(size(U));

for i = 1:n
    U(i,:) = u(dSites(i,1),dSites(i,2)); % interpolation condition for u
    V(i,:) = v(dSites(i,1),dSites(i,2)); % interpolation condition for v
end

M = [U; ...     % This matrix has this particular format to impose the
     V];        % interpolation conditions. Divergence-free condition
                % comes from the stream function now. See below for
                % more information.

% Transforming u and v from symbolic vectors to annonymous functions that
% depends on their coefficients and independent variables.
u = matlabFunction(u(x,y)*coeffs,'vars',{x y coeffs});
v = matlabFunction(v(x,y)*coeffs,'vars',{x y coeffs});
end

%% Comments
% One thing worth mentioning is the fact that, after some numerical
% experiments, we observed that the interpolation condition is not always
% satisfied. The linear system $M*\tt{coeffs} = \mathbf{f}$ is solved
% through least-squares, so the solution that we get is the best
% divergence-free polynomial that minimizes the error on the interpolation
% condition.
%
% Another notable fact is that if we choose the degree $N$ of the
% polynomial to be higher or equal to the number of points $n$ we get
% rank-deficient problem. Matlab displays an warning since there are
% multiple least-squares solution and *returns the one with as few non-zero
% entries as possible*. Moreover, since our polynomial has more degrees of
% freedom to ajust to the vector field to be interpolated, we get *double
% the accuracy* on the derivatives related to the divergence-free condition
% ($u_x$ and $v_y$). See <testConvergenceDerivativeStream.m
% |testConvergenceDerivativeStream.m|>